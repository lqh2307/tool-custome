#!/usr/bin/env python3

import argparse
import numpy
import rasterio
import os
from multiprocessing import Pool
from rasterio.windows import Window


# ========= ENCODE =========
def data_to_rgb(data, base_val, interval):
	data = data.astype(numpy.float64)
	data = (data - base_val) / interval

	if data.max() - data.min() > 256 ** 3:
		raise ValueError("Data range too large for RGB encoding")

	rgb = numpy.zeros((3, *data.shape), dtype=numpy.uint8)
	rgb[2] = data % 256
	rgb[1] = (data // 256) % 256
	rgb[0] = (data // (256 * 256)) % 256

	return rgb


def _encode_worker(args):
	data, base_val, interval = args

	return data_to_rgb(data, base_val, interval)


if __name__ == "__main__":
	parser = argparse.ArgumentParser(description="Convert DEM GeoTIFF to RGB (Terrain-RGB) GeoTIFF")
	parser.add_argument("-in", "--input", required=True, help="Input DEM GeoTIFF")
	parser.add_argument("-out", "--output", required=True, help="Output RGB GeoTIFF")
	parser.add_argument("-b", "--base-val", type=float, default=-10000, help="Base value")
	parser.add_argument("-i", "--interval", type=float, default=0.1, help="Interval")
	parser.add_argument("-w", "--workers", type=int, default=1, help="Number of worker processes")
	parser.add_argument("-c", "--compression", action="store_true", help="Enable compression for output GeoTIFF")

	args = parser.parse_args()
	workers = max(1, args.workers)

	with rasterio.open(args.input) as src:
		profile = src.profile.copy()
		profile.update(
			dtype="uint8",
			count=3,
			nodata=None,
			tiled=True,
			blockxsize=512,
			blockysize=512,
			bigtiff="YES",
		)

		if args.compression:
			profile.update(
				compress="LZW",
				predictor=2,
			)

		block_h, block_w = src.block_shapes[0]

		with rasterio.open(args.output, "w", **profile) as dst:
			if workers == 1:
				for y in range(0, src.height, block_h):
					for x in range(0, src.width, block_w):
						w = Window(
							x, y,
							min(block_w, src.width - x),
							min(block_h, src.height - y),
						)

						dst.write(data_to_rgb(src.read(1, window=w), args.base_val, args.interval), window=w)
			else:
				with Pool(workers) as pool:
					for y in range(0, src.height, block_h):
						tasks = []
						windows = []

						for x in range(0, src.width, block_w):
							w = Window(
								x, y,
								min(block_w, src.width - x),
								min(block_h, src.height - y),
							)

							tasks.append((src.read(1, window=w), args.base_val, args.interval))

							windows.append(w)

						for w, rgb in zip(windows, pool.imap(_encode_worker, tasks)):
							dst.write(rgb, window=w)
