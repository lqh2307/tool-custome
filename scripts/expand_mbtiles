#!/usr/bin/env python3

from pathlib import Path
import argparse
import sqlite3
import hashlib
import logging
import signal
import time
import sys


# ========= LOGS =========
LOGGER = logging.getLogger(__name__)
handler = logging.StreamHandler()
handler.setFormatter(logging.Formatter("%(asctime)s %(levelname)5s: %(message)s"))
LOGGER.addHandler(handler)
LOGGER.setLevel(logging.INFO)


def optimize_connect(cur):
	cur.execute("PRAGMA journal_mode = OFF;")
	cur.execute("PRAGMA synchronous = OFF;")
	cur.execute("PRAGMA foreign_keys = OFF;")
	cur.execute("PRAGMA encoding = 'UTF-8';")
	cur.execute("PRAGMA page_size = 65536;")


def ensure_schema(cur, metadata_index, tiles_index):
	if metadata_index:
		cur.execute("CREATE UNIQUE INDEX IF NOT EXISTS metadata_index ON metadata (name);")

	if tiles_index:
		cur.execute("CREATE UNIQUE INDEX IF NOT EXISTS tiles_index ON tiles (zoom_level, tile_column, tile_row);")

	cur.execute("PRAGMA table_info (tiles);")
	cols = { row[1] for row in cur.fetchall() }

	if "hash" not in cols:
		cur.execute("ALTER TABLE tiles ADD COLUMN hash TEXT;")

	if "created" not in cols:
		cur.execute("ALTER TABLE tiles ADD COLUMN created BIGINT;")


def expand_mbtiles(conn, cur, batch_size):
	created = int(time.time() * 1000)

	select_query = "SELECT zoom_level, tile_column, tile_row, tile_data FROM tiles WHERE hash IS NULL LIMIT ?;"
	update_query = "UPDATE tiles SET hash = ?, created = ? WHERE zoom_level = ? AND tile_column = ? AND tile_row = ?;"

	conn.execute("BEGIN;")
	
	while True:
		cur.execute(select_query, (batch_size,))

		rows = cur.fetchall()
		if not rows:
			break

		for z, x, y, tile_data in rows:
			cur.execute(update_query, (hashlib.md5(tile_data).hexdigest(), created, z, x, y))

	conn.execute("COMMIT;")


if __name__ == "__main__":
	signal.signal(signal.SIGINT, lambda sig, frame: (
		LOGGER.info('Received "SIGINT" signal. Exitting...'),

		sys.exit(0)
	))

	signal.signal(signal.SIGTERM, lambda sig, frame: (
		LOGGER.info('Received "SIGTERM" signal. Exitting...'),

		sys.exit(0)
	))

	parser = argparse.ArgumentParser(description="Expand MBTiles")
	parser.add_argument("-in", "--input", required=True, type=Path, help="Input MBTiles")
	parser.add_argument("-b", "--batch-size", required=False, type=int, default=1000, help="Batch size")
	parser.add_argument("-mi", "--metadata-index", required=False, action="store_true", help="Create metadata unique index")
	parser.add_argument("-ti", "--tiles-index", required=False, action="store_true", help="Create tiles unique index")

	args = parser.parse_args()

	LOGGER.info(f"Expand MBTiles {args.input}...")

	conn = sqlite3.connect(args.input)
	cur = conn.cursor()

	optimize_connect(cur)

	ensure_schema(cur, args.metadata_index, args.tiles_index)
				
	expand_mbtiles(conn, cur, args.batch_size)

	conn.close()

	LOGGER.info(f"Expanded MBTiles {args.input}!")
